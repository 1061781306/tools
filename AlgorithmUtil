package com.jf.parent.util;

import com.jf.parent.common.constant.ServerConstant;
import org.springframework.util.StringUtils;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * HMAC_SHA1加密算法、MD5加密算法
 * 此方法对照海康请求头header需求
 */
public class AlgorithmUtil {
	/**
	 * 字符串MD5加密算法
	 * @param sourceStr
	 * @return
	 */
	public static String MD5(String sourceStr)
	{
		MessageDigest mdInst;
		try
		{
			mdInst = MessageDigest.getInstance("MD5");
			mdInst.update(sourceStr.getBytes());

			byte[] md = mdInst.digest();
			StringBuffer buf = new StringBuffer();
			for (int i = 0; i < md.length; ++i) {
				int tmp = md[i];
				if (tmp < 0)
					tmp += 256;
				if (tmp < 16)
					buf.append("0");
				buf.append(Integer.toHexString(tmp));
			}
			return buf.toString();
		} catch (Exception e) {
			e.printStackTrace(); 
		}
		return null;
	}
	/**
	 * 二进制数组MD5加密算法
	 * @param sourceStr
	 * @return
	 */
	public static String MD5(byte[] sourceStr)
	{
		MessageDigest mdInst;
		try {
			mdInst = MessageDigest.getInstance("MD5");

			mdInst.update(sourceStr);

			byte[] md = mdInst.digest();

			StringBuffer buf = new StringBuffer();
			for (int i = 0; i < md.length; ++i) {
				int tmp = md[i];
				if (tmp < 0)
					tmp += 256;
				if (tmp < 16)
					buf.append("0");
				buf.append(Integer.toHexString(tmp));
			}

			return buf.toString();
		} catch (Exception e) {
			e.printStackTrace(); 
		}
		return null;
	}
	/**
	 * 对输入流对象进行MD5加密算法
	 * @param inputStream
	 * @return
	 */
	public static String MD5(InputStream inputStream){
		
		MessageDigest mdInst;
		try {
			mdInst = MessageDigest.getInstance("MD5");
			
			byte[] buff = new byte[512];
			int len;
			while ((len = inputStream.read(buff)) != -1){
				mdInst.update(buff, 0, len);
			}

			byte[] md = mdInst.digest();

			StringBuffer buf = new StringBuffer();
			for (int i = 0; i < md.length; ++i) {
				int tmp = md[i];
				if (tmp < 0)
					tmp += 256;
				if (tmp < 16)
					buf.append("0");
				buf.append(Integer.toHexString(tmp));
			}

			return buf.toString();
		} catch (Exception e) {
			e.printStackTrace(); 
		}
		return null;
	}
	/**
	 * 海康要求的HMAC_SHA1算法
	 * @param encryptText
	 * @param encryptKey
	 * @return
	 * @throws Exception
	 */
	public static byte[] HmacSHA1Encrypt(String encryptText, String encryptKey)
			throws Exception
	{
		byte[] data = encryptKey.getBytes("UTF-8");
		SecretKey secretKey = new SecretKeySpec(data, "HmacSHA1");
		
		Mac mac = Mac.getInstance("HmacSHA1");
		mac.init(secretKey);
		
		byte[] text = encryptText.getBytes("UTF-8");
		return mac.doFinal(text);
	}
	/**
	 * base64加密算法
	 * @param data
	 * @return
	 */
	public static char[] base64Encode(byte[] data)
	{
		char[] alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".toCharArray();
		char[] out = new char[(data.length + 2) / 3 * 4];

		int i = 0; 
		for (int index = 0; i < data.length; ){
			boolean quad = false;
			boolean trip = false;
			int val = 0xFF & data[i];
			val <<= 8;
			if (i + 1 < data.length)
			{
				val |= 0xFF & data[(i + 1)];
				trip = true;
			}
			val <<= 8;
			if (i + 2 < data.length)
			{
				val |= 0xFF & data[(i + 2)];
				quad = true;
			}
			out[(index + 3)] = quad ? alphabet[(val & 0x3F)] : alphabet[64];
			val >>= 6;
			out[(index + 2)] = trip ? alphabet[(val & 0x3F)] : alphabet[64];
			val >>= 6;
			out[(index + 1)] = alphabet[(val & 0x3F)];
			val >>= 6;
			out[(index + 0)] = alphabet[(val & 0x3F)];

			i += 3; index += 4;
		}
		return out;
	}
	
	 /**
     *  利用java原生的摘要实现SHA256加密
     * @param str 加密后的报文
     * @return
     */
    public static String getSHA256StrJava(String str){
        MessageDigest messageDigest;
        String encodeStr = "";
        try {
            messageDigest = MessageDigest.getInstance("SHA-256");
            messageDigest.update(str.getBytes("UTF-8"));
            encodeStr = byte2Hex(messageDigest.digest());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return encodeStr;
    }
    
    /**
     * 将byte转为16进制
     * @param bytes
     * @return
     */
    private static String byte2Hex(byte[] bytes){
        StringBuffer stringBuffer = new StringBuffer();
        String temp = null;
        for (int i=0;i<bytes.length;i++){
            temp = Integer.toHexString(bytes[i] & 0xFF);
            if (temp.length()==1){
                //1得到一位的进行补0操作
                stringBuffer.append("0");
            }
            stringBuffer.append(temp);
        }
        return stringBuffer.toString();
    }

	/**
	 * DES加密
	 * @param str 需要加密处理的字符串
	 * @return 经过Base64处理过的密文
	 */
	public static String encrypt(String str){
		if (StringUtils.isEmpty(str)){
			return "";
		}
		DESKeySpec dks;
		Cipher ecipher;
		try {
			byte[] utf8 = str.getBytes("UTF8");
			//使用原始密钥数据创建DESKeySpec对象
			dks = new DESKeySpec(ServerConstant.SECRET_KEY.getBytes());
			//创建一个密钥工厂
			SecretKeyFactory skf = SecretKeyFactory.getInstance("DES");
			//用密钥工厂把DESKeySpec转换成一个SecretKey对象
			SecretKey desKey = skf.generateSecret(dks);
			//Cipher对象实际完成加密操作
			ecipher = Cipher.getInstance("DES");
			//用密钥初始化Cipher对象
			ecipher.init(Cipher.ENCRYPT_MODE, desKey);
			//正式执行加密操作
			byte[] enc = ecipher.doFinal(utf8);
			//返回经过Base64处理过的密文
			return new sun.misc.BASE64Encoder().encode(enc);
		} catch (Exception e){
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * DES解密
	 * @param str 需要解密的字符串
	 * @return
	 */
	public static String decrypt(String str){
		if (StringUtils.isEmpty(str)){
			return "";
		}
		DESKeySpec dks;
		Cipher dcipher;
		try {
			byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);
//			dks = new DESKeySpec(Constants.EncryptDecryptKEY.getBytes());
			//使用原始密钥数据创建DESKeySpec对象
			dks = new DESKeySpec(ServerConstant.SECRET_KEY.getBytes());
			//创建一个密钥工厂
			SecretKeyFactory skf = SecretKeyFactory.getInstance("DES");
			//用密钥工厂把DESKeySpec转换成一个SecretKey对象
			SecretKey desKey = skf.generateSecret(dks);
			//Cipher对象实际完成解密操作
			dcipher = Cipher.getInstance("DES");
			//用密钥初始化Cipher对象
			dcipher.init(Cipher.DECRYPT_MODE, desKey);
			//正式执行解密操作
			byte[] result = dcipher.doFinal(dec);
			return new String(result, "UTF8");
		} catch (Exception e){
			e.printStackTrace();
		}
		return null;
	}
}
